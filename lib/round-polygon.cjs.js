"use strict";const m=e=>Math.round(e*1e10)/1e10,f=(e,l)=>m(Math.sqrt((l.x-e.x)*(l.x-e.x)+(l.y-e.y)*(l.y-e.y))),y=(e,l,t)=>{if(t){const a=f(e,l),g=f(l,t),s=f(t,e);return Math.acos((a*a+g*g-s*s)/(2*a*g))}else return Math.atan2(l.y-e.y,l.x-e.x)},x=Math.PI,L=x*2,E=(e,l)=>{const t=l-e;return t>x&&t<L||t<0&&t>-x?-1:1},N=(e,l,t)=>{const a=y(e,l,t),g=y(l,e),s=y(l,t),h=1/Math.tan(a/2),n=E(g,s),o=g+n*a/2;return{main:a,next:s,prev:g,vel:h,dir:n,bis:o}},R=(e,l=0)=>{const t=[],a=[],g=[],s=[];if(e.forEach((n,o)=>{const b=e[(o-1+e.length)%e.length],c=e[(o+1)%e.length],M=f(n,c),k=f(b,n),i=N(b,n,c);i.main===0&&(i.main=Number.EPSILON,i.vel=Number.MAX_SAFE_INTEGER),i.main===x&&(i.vel=0);const v={...n,angle:i,offset:0,arc:{radius:l,hit:l,lim:n.r!==void 0?Math.min(M/i.vel,k/i.vel,n.r):0},in:{length:k,rest:k},out:{length:M,rest:M},locked:!1,id:o,get prev(){return t[(o-1+e.length)%e.length]},get next(){return t[(o+1)%e.length]}};isNaN(i.main)&&(i.main=0,i.bis=i.prev||i.next,s.push(v)),typeof n.r=="number"?n.r===0?s.push(v):a.push(v):g.push(v),t.push(v)}),s.length&&s.forEach(n=>{n.angle.vel=0,n.arc.radius=0,P(n)}),t.forEach(n=>{n.arc.hit=Math.min(n.out.rest/(n.angle.vel+n.next.angle.vel),n.in.rest/(n.angle.vel+n.prev.angle.vel))}),a.length){let n=d(a);for(;n;)I(n),n=d(a)}if(g.length&&l>0){let n=d(t);for(;n;)H(n,l),n=d(t)}const h=t.map(n=>{const o=n.arc.radius/Math.sin(n.angle.main/2);return{id:n.id,x:n.x,y:n.y,angle:{main:m(n.angle.main),prev:n.angle.prev,next:n.angle.next,bis:n.angle.bis,dir:n.angle.dir},offset:m(n.offset),arc:{radius:m(n.arc.radius),x:n.x+(Math.cos(n.angle.bis)*o||0),y:n.y+(Math.sin(n.angle.bis)*o||0)},in:{length:n.in.length,x:n.x+Math.cos(n.angle.prev)*n.offset,y:n.y+Math.sin(n.angle.prev)*n.offset},out:{length:n.out.length,x:n.x+Math.cos(n.angle.next)*n.offset,y:n.y+Math.sin(n.angle.next)*n.offset},get prev(){return h[(n.id-1+e.length)%e.length]},get next(){return h[(n.id+1)%e.length]}}});return h},I=e=>{const{prev:l,next:t}=e;l.locked&&!t.locked?e.arc.radius=Math.min(Math.max((e.out.length-t.arc.lim*t.angle.vel)/e.angle.vel,e.out.length/(e.angle.vel+t.angle.vel)),e.in.rest/e.angle.vel,e.arc.lim):t.locked&&!l.locked?e.arc.radius=Math.min(Math.max((e.in.length-l.arc.lim*l.angle.vel)/e.angle.vel,e.in.length/(e.angle.vel+l.angle.vel)),e.out.rest/e.angle.vel,e.arc.lim):t.locked&&l.locked?e.arc.radius=Math.min(e.in.rest/e.angle.vel,e.out.rest/e.angle.vel,e.arc.lim):e.arc.radius=Math.min(Math.max((e.in.length-l.arc.lim*l.angle.vel)/e.angle.vel,e.in.length/(e.angle.vel+l.angle.vel)),Math.max((e.out.length-t.arc.lim*t.angle.vel)/e.angle.vel,e.out.length/(e.angle.vel+t.angle.vel)),e.arc.lim),P(e)},H=(e,l)=>{if(l>e.arc.hit){const{prev:t,next:a}=e;t.locked&&!a.locked?e.arc.radius=Math.max(Math.min(e.in.rest/e.angle.vel,e.out.length/(e.angle.vel+a.angle.vel),e.arc.radius),0):a.locked&&!t.locked?e.arc.radius=Math.max(Math.min(e.out.rest/e.angle.vel,e.in.length/(e.angle.vel+t.angle.vel),e.arc.radius),0):a.locked&&t.locked?e.arc.radius=Math.max(Math.min(e.in.rest/e.angle.vel,e.out.rest/e.angle.vel,e.arc.radius),0):e.arc.radius=e.arc.hit}P(e)},P=e=>{const{prev:l,next:t}=e;e.offset=e.arc.radius*e.angle.vel,l.out.rest-=e.offset,e.in.rest-=e.offset,e.out.rest-=e.offset,t.in.rest-=e.offset,e.locked=!0,l.arc.hit=Math.min(l.in.length/(l.angle.vel+l.prev.angle.vel),l.in.rest/l.angle.vel,l.out.rest/l.angle.vel),t.arc.hit=Math.min(t.out.length/(t.angle.vel+t.next.angle.vel),t.out.rest/t.angle.vel,t.in.rest/t.angle.vel)},d=e=>e.reduce((l,t)=>t.locked?l:l?t.arc.hit<l.arc.hit?t:l:t,null);module.exports=R;
