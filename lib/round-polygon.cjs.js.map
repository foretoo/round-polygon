{"version":3,"file":"round-polygon.cjs.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import { Point } from \"./types\"\n\nexport const getLength = (\n  A: Point, B: Point,\n) => Math.sqrt(Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2))\n\nexport const getAngle = (\n  A: Point, B: Point, C?: Point,\n) => {\n  if (!C)\n    return Math.atan2(B.y - A.y, B.x - A.x)\n  else {\n    const AB = getLength(A, B),\n          BC = getLength(B, C),\n          CA = getLength(C, A)\n\n    return Math.acos((AB*AB + BC*BC - CA*CA) / (2*AB*BC))\n  }\n}\n\nconst PI = Math.PI, TAU = PI * 2\n\nexport const getClockDir = (\n  angle1: number, angle2: number\n) => {\n  const diff = angle2 - angle1\n  return (\n    (diff > PI && diff < TAU) ||\n    (diff < 0  && diff > -PI)\n    ? -1 : 1\n  )\n}\n\nexport const getAngles = (\n  prev_point: Point,\n  curr_point: Point,\n  next_point: Point,\n) => {\n  const\n    main = getAngle(prev_point, curr_point, next_point),\n    prev = getAngle(curr_point, prev_point),\n    next = getAngle(curr_point, next_point),\n    vel = 1 / Math.tan(main / 2),\n    dir  = getClockDir(prev, next),\n    bis  = prev + dir * main / 2\n  \n  return { main, next, prev, vel, dir, bis }\n}\n\nexport const assignValue = <T>(\n  value: T, arr: T[], length: number\n) => {\n  if (arr.length < length) arr.push(value)\n  else {\n    for (let i = 0; i < arr.length - 1; i++) {\n      arr[i] = arr[i + 1]\n    }\n    arr[length - 1] = value\n  }\n}","import { Point, Linked, PreRoundedPoint, RoundedPoint } from \"./types\"\nimport { getLength, getAngles } from \"./utils\"\n\n\n\nlet i: number\nconst roundPolygon = (\n  points: Point[], radius: number\n): Linked<RoundedPoint>[] => {\n\n  i = points.length\n\n  // prepare points, calc angles\n  const preRoundedPoints: Linked<PreRoundedPoint>[] =\n  points.map((curr, id) => {\n\n    const\n      prev = points[(id - 1 + points.length) % points.length],\n      next = points[(id + 1) % points.length],\n      next_length = getLength(curr, next),\n      prev_length = getLength(prev, curr),\n      angle = getAngles(prev, curr, next)\n\n    return {\n      ...curr,\n      angle,\n      offset: 0,\n      arc: { radius, hit: radius },\n      in: { length: prev_length, rest: prev_length },\n      out: { length: next_length, rest: next_length },\n      locked: false,\n      id,\n      get prev() { return preRoundedPoints[(id - 1 + points.length) % points.length] },\n      get next() { return preRoundedPoints[(id + 1) % points.length] },\n    }\n  })\n\n  // calc collision radius for each point\n  preRoundedPoints.forEach((p) => {\n    p.arc.hit = Math.min(\n      p.out.length / (p.angle.vel + p.next.angle.vel),\n      p.in.length  / (p.angle.vel + p.prev.angle.vel),\n    )\n  })\n\n  // calc valid radius and edge offset\n  while (i) {\n    preRoundedPoints.sort(minArcHit)\n    calcRound(preRoundedPoints[0], preRoundedPoints, radius)\n  }\n  preRoundedPoints.sort((a, b) => a.id - b.id)\n\n  // final calc coordinates\n  const roundedPoints: Linked<RoundedPoint>[] =\n  preRoundedPoints.map((p, id) => {\n\n    const\n      bisLength = p.arc.radius / Math.sin(p.angle.main / 2),\n      offset = p.arc.radius * p.angle.vel\n\n    return {\n      x: p.x,\n      y: p.y,\n      angle: {\n        main: p.angle.main,\n        prev: p.angle.prev,\n        next: p.angle.next,\n        bis:  p.angle.bis,\n        dir:  p.angle.dir,\n      },\n      offset,\n      arc: {\n        radius: p.arc.radius,\n        x: p.x + Math.cos(p.angle.bis) * bisLength,\n        y: p.y + Math.sin(p.angle.bis) * bisLength,\n      },\n      in: {\n        length: p.in.length,\n        x: p.x + Math.cos(p.angle.prev) * offset,\n        y: p.y + Math.sin(p.angle.prev) * offset,\n      },\n      out: {\n        length: p.out.length,\n        x: p.x + Math.cos(p.angle.next) * offset,\n        y: p.y + Math.sin(p.angle.next) * offset,\n      },\n      id,\n      get prev() { return roundedPoints[(id - 1 + points.length) % points.length] },\n      get next() { return roundedPoints[(id + 1) % points.length] },\n    }\n  })\n\n  return roundedPoints\n}\n\n\n\nconst calcRound = (\n  curr:   Linked<PreRoundedPoint>,\n  points: Linked<PreRoundedPoint>[],\n  radius: number\n) => {\n\n  if (!curr.locked) {\n    const prev = points.find((p) => p.id === (curr.id - 1 + points.length) % points.length)!\n    const next = points.find((p) => p.id === (curr.id + 1) % points.length)!\n\n    if (radius >= curr.arc.hit) {\n      if (curr.arc.hit === next.arc.hit) {\n        const _prev  = points.find((p) => p.id === (prev.id - 1 + points.length) % points.length)!\n        const _next  = points.find((p) => p.id === (next.id + 1) % points.length)!\n        const _nnext = points.find((p) => p.id === (_next.id + 1) % points.length)!\n\n        curr.arc.radius = curr.arc.hit\n        next.arc.radius = curr.arc.hit\n        next.locked = true\n        curr.locked = true\n        i -= 2\n\n        curr.offset = curr.arc.radius * curr.angle.vel\n        next.offset = next.arc.radius * next.angle.vel\n\n       _next.in.rest  -= next.offset\n        next.out.rest -= next.offset\n        next.in.rest  -= next.offset\n        next.in.rest  -= curr.offset\n        curr.out.rest -= curr.offset\n        curr.in.rest  -= curr.offset\n        prev.out.rest -= curr.offset\n\n       _next.arc.hit = Math.min(\n          _next.out.length / (_next.angle.vel + _nnext.angle.vel),\n          _next.in.rest / _next.angle.vel\n        )\n        prev.arc.hit = Math.min(\n          prev.in.length / (prev.angle.vel + _prev.angle.vel),\n          prev.out.rest / prev.angle.vel\n        )\n      }\n      else if (curr.arc.hit === prev.arc.hit) {\n        const _next  = points.find((p) => p.id === (next.id + 1) % points.length)!\n        const _prev  = points.find((p) => p.id === (prev.id - 1 + points.length) % points.length)!\n        const _pprev = points.find((p) => p.id === (_prev.id - 1 + points.length) % points.length)!\n\n        curr.arc.radius = curr.arc.hit\n        prev.arc.radius = curr.arc.hit\n        curr.locked = true\n        prev.locked = true\n        i -= 2\n\n        curr.offset = curr.arc.radius * curr.angle.vel\n        prev.offset = prev.arc.radius * prev.angle.vel\n\n       _prev.out.rest -= prev.offset\n        prev.in.rest  -= prev.offset\n        prev.out.rest -= prev.offset\n        prev.out.rest -= curr.offset\n        curr.in.rest  -= curr.offset\n        curr.out.rest -= curr.offset\n        next.in.rest  -= curr.offset\n\n       _prev.arc.hit = Math.min(\n          _prev.in.length / (_prev.angle.vel + _pprev.angle.vel),\n          _prev.out.rest / _prev.angle.vel\n        )\n        next.arc.hit = Math.min(\n          next.out.length / (next.angle.vel + _next.angle.vel),\n          next.in.rest / next.angle.vel\n        )\n      }\n      else {\n\n        if (prev.locked && !next.locked) {\n          curr.arc.radius = Math.min(\n            curr.in.rest / curr.angle.vel,\n            curr.out.length / (curr.angle.vel + next.angle.vel),\n            curr.arc.radius\n          )\n        }\n        if (next.locked && !prev.locked) {\n          curr.arc.radius = Math.min(\n            curr.out.rest / curr.angle.vel,\n            curr.in.length / (curr.angle.vel + prev.angle.vel),\n            curr.arc.radius\n          )\n        }\n        if (next.locked && prev.locked) {          \n          curr.arc.radius = Math.min(\n            curr.in.rest / curr.angle.vel,\n            curr.out.rest / curr.angle.vel,\n            curr.arc.radius\n          )\n        }\n\n        curr.offset = curr.arc.radius * curr.angle.vel\n\n        prev.out.rest -= curr.offset\n        curr.in.rest -= curr.offset\n        curr.out.rest -= curr.offset\n        next.in.rest -= curr.offset\n\n        curr.locked = true\n        i--\n      }\n    }\n    else {\n      curr.offset = curr.arc.radius * curr.angle.vel\n\n      prev.out.rest -= curr.offset\n      curr.in.rest -= curr.offset\n      curr.out.rest -= curr.offset\n      next.in.rest -= curr.offset\n\n      curr.locked = true\n      i--\n    }\n  }\n}\n\n\n\nconst minArcHit = (\n  a: Linked<PreRoundedPoint>, b: Linked<PreRoundedPoint>\n) => {\n  if (a.locked && !b.locked) return 1\n  else if (!a.locked && b.locked) return -1\n  else if (a.locked && b.locked) return 0\n  else return a.arc.hit - b.arc.hit\n}\n\n\n\nexport default roundPolygon"],"names":[],"mappings":"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"}