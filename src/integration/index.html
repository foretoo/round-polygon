<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>round-polygon demo</title>
  </head>
  <body>
    <script>
    
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
function ___$insertStyle(css) {
    if (!css || typeof window === 'undefined') {
        return;
    }
    const style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
}

___$insertStyle("* {\n  margin: 0;\n  padding: 0;\n  border: none;\n  font-family: monospace;\n  font-size: 20px;\n  line-height: 1rem;\n  box-sizing: border-box;\n}\n\nhtml, body {\n  width: 100%;\n  height: 100%;\n}\n\nbody {\n  display: grid;\n  place-items: center;\n  background-color: #111;\n}\n\ncanvas {\n  display: block;\n}\ncanvas.bg {\n  height: 0px;\n}\ncanvas.grab {\n  cursor: pointer;\n}\ncanvas.grabbing {\n  cursor: grabbing;\n}\ncanvas.grabbing + div {\n  pointer-events: none;\n}\n\ndiv, p {\n  position: absolute;\n  font-size: 0.8rem;\n  line-height: 1em;\n  color: #aaa;\n}\n\ndiv {\n  width: 50%;\n  top: 2rem;\n  display: grid;\n  place-self: start center;\n  gap: 0.5rem;\n}\ndiv.hidden {\n  display: none;\n}\ndiv span {\n  font-size: inherit;\n}\n\np {\n  bottom: 2rem;\n  text-align: center;\n}");

const PI$2 = Math.PI, TAU$1 = PI$2 * 2, CLOSE = "CLOSE";

let width$1, height$1, canvas, ctx, pr;
const getcanvas = (w, h, id) => {
  canvas = document.createElement("canvas");
  ctx = canvas.getContext("2d");
  document.body.prepend(canvas);
  canvas.setAttribute("id", id ? id : "canvas");
  pr = window.devicePixelRatio;
  if (w) {
    width$1 = w;
    height$1 = h ? h : width$1;
    canvas.setAttribute("style", `width:${width$1}px;height:${height$1}px;`);
    canvas.setAttribute("width", (width$1 * pr).toString());
    canvas.setAttribute("height", (height$1 * pr).toString());
  }
  else {
    canvas.setAttribute("style", "width:100%;height:100%;");
    ({ width: width$1, height: height$1 } = canvas.getBoundingClientRect());
    canvas.setAttribute("width", (width$1 * pr).toString());
    canvas.setAttribute("height", (height$1 * pr).toString());
  }
  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.imageSmoothingEnabled = true;
  return { width: width$1, height: height$1, ctx, canvas }
};
let shaping = false;
const ctxshape = (arg) => {
  if (arg === "CLOSE") ctx.closePath();
  if (shaping) {
    shaping = false;
    draw$1();
  }
  else ctx.beginPath();
};
const ctxvertex = (x, y) => {
  if (shaping) ctx.lineTo(x * pr, y * pr);
  else {
    shaping = true;
    ctx.moveTo(x * pr, y * pr);
  }
};
const ctxcircle = (x, y, r = 10, from, to) => {
  ctx.beginPath();
  ctx.arc(x * pr, y * pr, r * pr, from || 0, to || TAU$1);
  draw$1();
};
let font_family = "sans-serif";
const font = (size, family, options) => {
  let fontsize = "", fontoptions = options ? options : "", fontfamily = font_family;
  if (family) font_family = fontfamily = family;
  if (typeof size === "number") fontsize = size * pr + "px";
  if (typeof size === "string") {
    const temp = size.match(/^(\d+)([a-z%]*)\/?(\d*)([a-z%]*)$/);
    if (temp) {
      fontsize = parseFloat(temp[1]) * pr + (temp[2] ? temp[2] : "px");
      if (temp[3]) {
        fontsize += `/${temp[3]}`;
        fontsize += temp[4] ? temp[4] : "px";
      }
    }
  }
  ctx.font = `${fontoptions} ${fontsize} ${fontfamily}`.trim();
};
let text_width;
const settext = (align, base, width2) => {
  ctx.textAlign = align;
  base && (ctx.textBaseline = base);
  width2 && (text_width = width2);
};
const text = (content, x, y, width2) => {
  let size = width2 || text_width;
  size = size !== void 0 ? size * pr : size;
  ctx.fillText(`${content}`, x * pr, y * pr, size);
  ctx.strokeText(`${content}`, x * pr, y * pr, size);
};
const draw$1 = () => {
  ctx.fill();
  ctx.stroke();
};
const fill = (color) => {
  color === null ? ctx.fillStyle = "transparent" : ctx.fillStyle = color;
};
const stroke = (color, width2, cap, join) => {
  color === null ? ctx.strokeStyle = "transparent" : ctx.strokeStyle = color;
  if (width2 !== void 0) ctx.lineWidth = width2 * pr;
  if (cap !== void 0) ctx.lineCap = cap;
  if (join !== void 0) ctx.lineJoin = join;
};
const clear = (x = 0, y = 0, w = width$1, h = height$1) => {
  ctx.clearRect(x * pr, y * pr, w * pr, h * pr);
};
let shape = ctxshape, vertex = ctxvertex, circle = ctxcircle;

const round = (n) => Math.round(n * 1e10) / 1e10;
const getLength = (A, B) => round(Math.sqrt((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y)));
const PI$1 = Math.PI, TAU = PI$1 * 2;
const getClockDir = (angle1, angle2) => {
  const diff = angle2 - angle1;
  return diff > PI$1 && diff < TAU || diff < 0 && diff > -PI$1 ? -1 : 1;
};
const getAngles = (prevpoint, currpoint, nextpoint, prevlen, mainlen, nextlen) => {
  const prev = Math.atan2(prevpoint.y - currpoint.y, prevpoint.x - currpoint.x), next = Math.atan2(nextpoint.y - currpoint.y, nextpoint.x - currpoint.x), main = Math.acos((prevlen * prevlen + nextlen * nextlen - mainlen * mainlen) / (2 * prevlen * nextlen)), vel = 1 / Math.tan(main / 2), dir = getClockDir(prev, next), bis = prev + dir * main / 2;
  return { prev, next, main, vel, dir, bis };
};

const PI = Math.PI;
const getSegments = (points, type, opt) => points.reduce((segmented, point) => {
  const { angle: { prev, next }, arc: { x, y, radius } } = point, dir = point.angle.dir * -1, startangle = prev + dir * PI / 2, angle = (dir * PI + next - prev) % PI, amount = type === "LENGTH" ? Math.round(dir * angle * radius / opt) : opt || 1, unitangle = angle / amount, vertices = [];
  for (let i = 0; i <= amount; i++)
    vertices.push({
      x: x + Math.cos(startangle + unitangle * i) * radius,
      y: y + Math.sin(startangle + unitangle * i) * radius
    });
  return segmented.concat(vertices);
}, []);

const roundPolygon = (points, radius = 0) => {
  const len = points.length, preRoundedPoints = [], limPoints = [], zeroLimPoints = [];
  points.forEach((curr, id) => {
    const prev = points[(id - 1 + len) % len], next = points[(id + 1) % len], prevlen = getLength(prev, curr), mainlen = getLength(prev, next), nextlen = getLength(curr, next), angle = getAngles(prev, curr, next, prevlen, mainlen, nextlen);
    if (angle.main === 0) {
      angle.main = Number.EPSILON;
      angle.vel = Number.MAX_SAFE_INTEGER;
    }
    if (angle.main === PI$1)
      angle.vel = 0;
    const preRoundedPoint = {
      x: curr.x,
      y: curr.y,
      angle,
      offset: 0,
      arc: {
        radius,
        hit: radius,
        lim: Math.min(nextlen / angle.vel, prevlen / angle.vel, curr.r || 0)
      },
      in: { length: prevlen, rest: prevlen },
      out: { length: nextlen, rest: nextlen },
      locked: false,
      id,
      get prev() {
        return preRoundedPoints[(id - 1 + len) % len];
      },
      get next() {
        return preRoundedPoints[(id + 1) % len];
      }
    };
    if (isNaN(angle.main)) {
      angle.main = 0;
      angle.bis = angle.prev || angle.next;
      zeroLimPoints.push(preRoundedPoint);
    }
    if (typeof curr.r === "number")
      if (curr.r === 0)
        zeroLimPoints.push(preRoundedPoint);
      else
        limPoints.push(preRoundedPoint);
    preRoundedPoints.push(preRoundedPoint);
  });
  zeroLimPoints.forEach((p) => {
    p.angle.vel = 0;
    p.arc.radius = 0;
    lockPoint(p);
  });
  preRoundedPoints.forEach((p) => {
    p.arc.hit = Math.min(p.out.rest / (p.angle.vel + p.next.angle.vel), p.in.rest / (p.angle.vel + p.prev.angle.vel));
  });
  let minHitPoint = getMinHit(limPoints);
  while (minHitPoint) {
    calcLimitRadius(minHitPoint);
    minHitPoint = getMinHit(limPoints);
  }
  minHitPoint = getMinHit(preRoundedPoints);
  while (minHitPoint) {
    calcCommonRadius(minHitPoint, radius);
    minHitPoint = getMinHit(preRoundedPoints);
  }
  const roundedPoints = preRoundedPoints.map((p) => {
    const bislen = p.arc.radius / Math.sin(p.angle.main / 2);
    return {
      id: p.id,
      x: p.x,
      y: p.y,
      angle: {
        main: round(p.angle.main),
        prev: p.angle.prev,
        next: p.angle.next,
        bis: p.angle.bis,
        dir: p.angle.dir
      },
      offset: round(p.offset),
      arc: {
        radius: round(p.arc.radius),
        x: p.x + (Math.cos(p.angle.bis) * bislen || 0),
        y: p.y + (Math.sin(p.angle.bis) * bislen || 0)
      },
      in: {
        length: p.in.length,
        x: p.x + Math.cos(p.angle.prev) * p.offset,
        y: p.y + Math.sin(p.angle.prev) * p.offset
      },
      out: {
        length: p.out.length,
        x: p.x + Math.cos(p.angle.next) * p.offset,
        y: p.y + Math.sin(p.angle.next) * p.offset
      },
      get prev() {
        return roundedPoints[(p.id - 1 + len) % len];
      },
      get next() {
        return roundedPoints[(p.id + 1) % len];
      }
    };
  });
  return roundedPoints;
};
const calcLimitRadius = (curr) => {
  const { prev, next } = curr;
  if (prev.locked && !next.locked)
    curr.arc.radius = Math.min(Math.max((curr.out.length - next.arc.lim * next.angle.vel) / curr.angle.vel, curr.out.length / (curr.angle.vel + next.angle.vel)), curr.in.rest / curr.angle.vel, curr.arc.lim);
  else if (next.locked && !prev.locked)
    curr.arc.radius = Math.min(Math.max((curr.in.length - prev.arc.lim * prev.angle.vel) / curr.angle.vel, curr.in.length / (curr.angle.vel + prev.angle.vel)), curr.out.rest / curr.angle.vel, curr.arc.lim);
  else if (next.locked && prev.locked)
    curr.arc.radius = Math.min(curr.in.rest / curr.angle.vel, curr.out.rest / curr.angle.vel, curr.arc.lim);
  else
    curr.arc.radius = Math.min(Math.max((curr.in.length - prev.arc.lim * prev.angle.vel) / curr.angle.vel, curr.in.length / (curr.angle.vel + prev.angle.vel)), Math.max((curr.out.length - next.arc.lim * next.angle.vel) / curr.angle.vel, curr.out.length / (curr.angle.vel + next.angle.vel)), curr.arc.lim);
  lockPoint(curr);
};
const calcCommonRadius = (curr, radius) => {
  if (radius > curr.arc.hit) {
    const { prev, next } = curr;
    if (prev.locked && !next.locked)
      curr.arc.radius = Math.max(Math.min(curr.in.rest / curr.angle.vel, curr.out.length / (curr.angle.vel + next.angle.vel), curr.arc.radius), 0);
    else if (next.locked && !prev.locked)
      curr.arc.radius = Math.max(Math.min(curr.out.rest / curr.angle.vel, curr.in.length / (curr.angle.vel + prev.angle.vel), curr.arc.radius), 0);
    else if (next.locked && prev.locked)
      curr.arc.radius = Math.max(Math.min(curr.in.rest / curr.angle.vel, curr.out.rest / curr.angle.vel, curr.arc.radius), 0);
    else
      curr.arc.radius = curr.arc.hit;
  }
  lockPoint(curr);
};
const lockPoint = (curr) => {
  const { prev, next } = curr;
  curr.offset = curr.arc.radius * curr.angle.vel;
  prev.out.rest -= curr.offset;
  curr.in.rest -= curr.offset;
  curr.out.rest -= curr.offset;
  next.in.rest -= curr.offset;
  curr.locked = true;
  prev.arc.hit = Math.min(prev.in.length / (prev.angle.vel + prev.prev.angle.vel), prev.in.rest / prev.angle.vel, prev.out.rest / prev.angle.vel);
  next.arc.hit = Math.min(next.out.length / (next.angle.vel + next.next.angle.vel), next.out.rest / next.angle.vel, next.in.rest / next.angle.vel);
};
const getMinHit = (arr) => arr.reduce((min, p) => p.locked ? min : !min ? p : p.arc.hit < min.arc.hit ? p : min, null);

const control = document.createElement("div");
document.body.prepend(control);
const radiusvalue = document.createElement("span");
control.appendChild(radiusvalue);
const radiusrange = document.createElement("input");
radiusrange.type = "range";
radiusrange.min = "0";
radiusrange.max = "500";
control.appendChild(radiusrange);

const { height, width } = getcanvas(), l = 50, ox = width / 2 - l * 2, oy = height / 2 - l * 2, grey = "#fffa", skin = "#7af7", highlight = "#4af", points = [
  { x: l * 5 + ox, y: l * 2 + oy },
  { x: l * 3 + ox, y: oy },
  { x: l * 3 + ox, y: l * 4 + oy },
  { x: ox - l, y: l * 4 + oy }
];
radiusrange.value = "25";
radiusrange.max = "100";
radiusvalue.textContent = radiusrange.value;
let polygon, formedPolygon;
polygon = roundPolygon(points, +radiusrange.value);
formedPolygon = getSegments(polygon, "LENGTH", 10);
function draw() {
  clear();
  fill(skin);
  stroke("#0000", 2);
  shape();
  formedPolygon.forEach((p) => vertex(p.x, p.y));
  shape(CLOSE);
  stroke(null);
  fill(highlight);
  formedPolygon.forEach((p) => circle(p.x, p.y, 1));
  polygon.forEach((p, i) => {
    stroke(null);
    fill(grey);
    font(14, "monospace");
    settext("center", "middle");
    const { bis } = p.angle, x = p.x - Math.cos(bis) * 24, y = p.y - Math.sin(bis) * 24;
    text(`${i}`, x, y);
  });
}
radiusrange.oninput = () => {
  radiusvalue.textContent = radiusrange.value;
  polygon = roundPolygon(points, +radiusrange.value);
  formedPolygon = getSegments(polygon, "LENGTH", 4);
  draw();
};

draw();

    </script>
  </body>
</html>